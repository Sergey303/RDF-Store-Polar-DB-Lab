
20150419 12:22
Начинаю новый проект в среде RDF-Store-Polar-DB-Lab. Несколько длинноватое название, трудно
запомнить. Проект будет заключаться в создании решений для RDF-движка (TripleStore) на основе
уже созданных решений по универсальному индексу и по универсальной таблице имен. 

Сначала надо за что-то зацепиться. Нужна инфраструктура триплетов. В частности, конструкция 
триплетного объекта и генерация потока триплетов. Посмотрю за что мне "цепляться". 

В принципе, проект RDFTripleStore струтктурирован вполне интересно. Попробую организовать
поток триплетов. 

Ура, получилось! И конфигуратор работает. Его только надо как-то прописать в проекте. Но так, чтобы
он не коммитился.

Теперь мне понадобится граф с интерфейсом IGraph. Граф будет содержать опорную таблицу и индексы.
Ну и методы, конечно. Сначала это будет граф, потроенный на строковых представлениях uri (без кодирования).

20150425 05:33
Почти неделю не работал над проектом... Попробую субботу и воскресенье провести, в этом смысле, эффективно.

Предыдущий этап закончился тем, что я смог построить базовую таблицу в строковом варианте (без кодирования)
и смог посроить индекс sp. После этого, индекс был испытан на данных, взятых из tracing1mln.xml, 13-я 
строка. Проблемы есть, но они "не у меня". Во-первых, я пока не нашел процедуру перевода ObjectVariants из 
объектного представления в структурное. Поэтому проверка правильности выполнена с помощью отладчика. 
Во-вторых, литеральное представление строки "пострадало" - строка исходно была в кавычках:
  <spD subj="http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer10/Product468" pred="http://www.w3.org/2000/01/rdf-schema#label" res="&quot;nonstrikers tambour&quot;" />
но кавычки не воспроизвелись. Посмотрю в код класса ObjectVariants.

Нашел преобразователь Writeble2OVariant(), сделанный в виде статического расширения массива объектов. 
Потом наткнулся на недоделку в виде отсутствия переопределения для ToString(). Сделал переопределение,
после этого получил (почти... с точностью до кавычек) требуемый результат. Кстати, переопределение
сделал не правильно. Правильно так, как текстовый синтаксис велит. Но пока пусь будет так. 

Теперь отложу класс GoGraphStringBased и сделаю (попробую сделать) вариант с кодированием. Кажется, 
все уже продумано, попробую воплотить.

Сначала ввод. Надо его переделать под ввод порциями. Где-то я это уже делал. Сейчас посмотрю.
Перенесу код BufferredProcessing (пока он не вошел в Поляровскую сборку).

Есть еще возможно слабое место в разработке: это объектный вариант:
    public class OV_typed : ObjectVariants
    {
        public readonly string value; public readonly string turi;
    }
Дело в том, что в дальнейшем, может захотеться прератить string turi в кодированное значение.
Пока это выглядит экзотикой, так что можно оставить строкой.

В строковом виде опорная таблица (для 1 млн. берлинского теста) занимает 235 Мб.

Похоже, таблица загрузилась. Это выполнялось 19 сек. Порциями по 500 тыс. База данных 76.5 мб. (!)
Забавно, что пропорция количества идентификаторов к триплетам прямо как у freebase - получилось
150 тыс. кодов.

Теперь попробую построить какой-то индекс, хотя бы s, sp.
Индекс по s (вроде построился) время построение базы данных - 22 сек.

В таблице имен на скорую руку сделаны "главные" методы преобразования строк в коды и обратно.

20150426 09:46
Вчера (вроде) построил индекс s. Сегодня хочу построить и некоторые другие. Также надо сформировать
испытательный стенд на основе файлов tracing. В этих файлах есть запуски поисков и есть результаты. 
Нет временных характеристик. Вроде были какие-то интегральные. Возможно они сохранились в PolarDemo.

Нашел. Год назад я отлаживал RdfTrees и проводил сопоставление с TrueRdfViewer. Главное, можно снова
пропускать эти тесты и выявлять особености тех или иных решений на трассировочных данных. Начинаю. 
Делаю стенд и испытание spO, spD. 

Стенд вопроизвел из предыдущего проекта. Пока могу испытать только spO, spD теперь с ним слился. 
Время тратится несуразно много - 14 сек. на 4 тыс запусков. В принципе, это понятно. Дело в том, 
что spO сейчас это сделанное средствами Linq-фильтрации sPO. Для проверки, реанимирую проект TrueRdfViewer.

Реанимировал. 1 млн. берлина загружается 14 сек. (а у нас - уже 22!). База данных имеет объем 80.3 Мб.
База данных GoTripleStore уже 88Мб.

Пока не проверил то, что наработал. По некоторым признакам, по результату должно быть нормально. 
Сделаю индекс sp. Для этого индекса ключ - пара sp, полуключ - хеш этой пары. 

Теперь строю и sp. Время 21 сек. (11 сек. загрузка, остальное - индексы). 4151 поиск по s p ?o.
А вот TrueRdfViewer дал заметно лучшие результаты: 7085 правильных результатов + 391 "неправильных" 
получилось за 612 мс. Правда есть тонкомть: в TrueRdfViewer используются таблицы spo и spd и запросы
также отличаются. В полтора раза... Не так чтобы сильно много, все же заложен динамизм и универсальность. 
Надо довести эксперимент до реализации всех вариантов. Т.е. нужны еще варианты Spo Spd spo. Похоже при
нынешнем подходе, это два варианта. 

Пытаюсь понять 976 мс. на sp это хорошо или плохо. Во первых надо узнать сколько выполнялось базовых операций.
Это можно измерить. 

Сообразил какое измерение произвести для того, чтобы понять время работы. Я остановил поиск на стадии
преобразования строк субъекта и предиката в коды. Это оказалось существенно: 533 мс. т.е. большую 
часть времени было преобразование. Вторую остановку сделал перед преобразованием результата поиска
в поток триплетов. Время практически финальное: 928-980 мс. Финальное время: 962-991 Можно предположить,
что 20-30 мс. (2-3%) можно сэкономить на том, что не формировать триплеты в выходной поток. Теперь по 
поводу кодирования (субъекта и предиката). Посмотрю все ли правильно я делаю. Как-то долго получается.

В принципе, все соответствует имеющимся нормативам. Расчитываю:
4151 поисков * 2 кодирования * 60 мс. = 500 мс. (!)

На рабочем компьютере результаты аналогичны. Время на тест: 480-520 мс.

 





   

 
 

 







 
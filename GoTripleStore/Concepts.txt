
20150419 12:22
Начинаю новый проект в среде RDF-Store-Polar-DB-Lab. Несколько длинноватое название, трудно
запомнить. Проект будет заключаться в создании решений для RDF-движка (TripleStore) на основе
уже созданных решений по универсальному индексу и по универсальной таблице имен. 

Сначала надо за что-то зацепиться. Нужна инфраструктура триплетов. В частности, конструкция 
триплетного объекта и генерация потока триплетов. Посмотрю за что мне "цепляться". 

В принципе, проект RDFTripleStore струтктурирован вполне интересно. Попробую организовать
поток триплетов. 

Ура, получилось! И конфигуратор работает. Его только надо как-то прописать в проекте. Но так, чтобы
он не коммитился.

Теперь мне понадобится граф с интерфейсом IGraph. Граф будет содержать опорную таблицу и индексы.
Ну и методы, конечно. Сначала это будет граф, потроенный на строковых представлениях uri (без кодирования).

20150425 05:33
Почти неделю не работал над проектом... Попробую субботу и воскресенье провести, в этом смысле, эффективно.

Предыдущий этап закончился тем, что я смог построить базовую таблицу в строковом варианте (без кодирования)
и смог посроить индекс sp. После этого, индекс был испытан на данных, взятых из tracing1mln.xml, 13-я 
строка. Проблемы есть, но они "не у меня". Во-первых, я пока не нашел процедуру перевода ObjectVariants из 
объектного представления в структурное. Поэтому проверка правильности выполнена с помощью отладчика. 
Во-вторых, литеральное представление строки "пострадало" - строка исходно была в кавычках:
  <spD subj="http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer10/Product468" pred="http://www.w3.org/2000/01/rdf-schema#label" res="&quot;nonstrikers tambour&quot;" />
но кавычки не воспроизвелись. Посмотрю в код класса ObjectVariants.

Нашел преобразователь Writeble2OVariant(), сделанный в виде статического расширения массива объектов. 
Потом наткнулся на недоделку в виде отсутствия переопределения для ToString(). Сделал переопределение,
после этого получил (почти... с точностью до кавычек) требуемый результат. Кстати, переопределение
сделал не правильно. Правильно так, как текстовый синтаксис велит. Но пока пусь будет так. 

Теперь отложу класс GoGraphStringBased и сделаю (попробую сделать) вариант с кодированием. Кажется, 
все уже продумано, попробую воплотить.

Сначала ввод. Надо его переделать под ввод порциями. Где-то я это уже делал. Сейчас посмотрю.
Перенесу код BufferredProcessing (пока он не вошел в Поляровскую сборку).

Есть еще возможно слабое место в разработке: это объектный вариант:
    public class OV_typed : ObjectVariants
    {
        public readonly string value; public readonly string turi;
    }
Дело в том, что в дальнейшем, может захотеться прератить string turi в кодированное значение.
Пока это выглядит экзотикой, так что можно оставить строкой.

В строковом виде опорная таблица (для 1 млн. берлинского теста) занимает 235 Мб.

Похоже, таблица загрузилась. Это выполнялось 19 сек. Порциями по 500 тыс. База данных 76.5 мб. (!)
Забавно, что пропорция количества идентификаторов к триплетам прямо как у freebase - получилось
150 тыс. кодов.

Теперь попробую построить какой-то индекс, хотя бы s, sp.
Индекс по s (вроде построился) время построение базы данных - 22 сек.

В таблице имен на скорую руку сделаны "главные" методы преобразования строк в коды и обратно.

20150426 09:46
Вчера (вроде) построил индекс s. Сегодня хочу построить и некоторые другие. Также надо сформировать
испытательный стенд на основе файлов tracing. В этих файлах есть запуски поисков и есть результаты. 
Нет временных характеристик. Вроде были какие-то интегральные. Возможно они сохранились в PolarDemo.

Нашел. Год назад я отлаживал RdfTrees и проводил сопоставление с TrueRdfViewer. Главное, можно снова
пропускать эти тесты и выявлять особености тех или иных решений на трассировочных данных. Начинаю. 
Делаю стенд и испытание spO, spD. 

Стенд вопроизвел из предыдущего проекта. Пока могу испытать только spO, spD теперь с ним слился. 
Время тратится несуразно много - 14 сек. на 4 тыс запусков. В принципе, это понятно. Дело в том, 
что spO сейчас это сделанное средствами Linq-фильтрации sPO. Для проверки, реанимирую проект TrueRdfViewer.

Реанимировал. 1 млн. берлина загружается 14 сек. (а у нас - уже 22!). База данных имеет объем 80.3 Мб.
База данных GoTripleStore уже 88Мб.

Пока не проверил то, что наработал. По некоторым признакам, по результату должно быть нормально. 
Сделаю индекс sp. Для этого индекса ключ - пара sp, полуключ - хеш этой пары. 

Теперь строю и sp. Время 21 сек. (11 сек. загрузка, остальное - индексы). 4151 поиск по s p ?o.
А вот TrueRdfViewer дал заметно лучшие результаты: 7085 правильных результатов + 391 "неправильных" 
получилось за 612 мс. Правда есть тонкомть: в TrueRdfViewer используются таблицы spo и spd и запросы
также отличаются. В полтора раза... Не так чтобы сильно много, все же заложен динамизм и универсальность. 
Надо довести эксперимент до реализации всех вариантов. Т.е. нужны еще варианты Spo Spd spo. Похоже при
нынешнем подходе, это два варианта. 

Пытаюсь понять 976 мс. на sp это хорошо или плохо. Во первых надо узнать сколько выполнялось базовых операций.
Это можно измерить. 

Сообразил какое измерение произвести для того, чтобы понять время работы. Я остановил поиск на стадии
преобразования строк субъекта и предиката в коды. Это оказалось существенно: 533 мс. т.е. большую 
часть времени было преобразование. Вторую остановку сделал перед преобразованием результата поиска
в поток триплетов. Время практически финальное: 928-980 мс. Финальное время: 962-991 Можно предположить,
что 20-30 мс. (2-3%) можно сэкономить на том, что не формировать триплеты в выходной поток. Теперь по 
поводу кодирования (субъекта и предиката). Посмотрю все ли правильно я делаю. Как-то долго получается.

В принципе, все соответствует имеющимся нормативам. Расчитываю:
4151 поисков * 2 кодирования * 60 мс. = 500 мс. (!)

На рабочем компьютере результаты аналогичны. Время на тест: 480-520 мс.

20150501 09:43
С Праздником вас, дорогие товарищи, с Днем 1-го мая - междунароным днем солидарности трудящихся!!!

219482
91115
88062
IriInt
Str
Date
Int
Other
DateTimeZone
Lang

iri 0
iriint 491779 различных 66 тыс., различных (p, o) 69255
bool 0
str 59216
lang 28480
double 0
decimal 0
float 0
int 148885 po-различных 6709
DateTimeZone 142400
datetime 0
date 94726
time 0
other 56960
0
0

Похоже, различных предикатов 29 (?)
Если я павильно подсчитал, то всего различных пар (po) 221830. Похоже, дело не в плохих функциях GetHashCode()

Немного восстановлю рабочий вариант программы

Восстановил. С настройками Сергея po-хеш обспечивает разными 219482 триплета. Время построения базы данных
192 сек. Объем базы данных 125 Мб.

Последняя трассировка Spo выполнялась 47 мс.

Попробую в позиции po базовый индекс.

Получилось в чем-то неплохо. Время загрузки базы данных 44 сек. но время трассировки стало 353 мс.
При повторном запуске, время трассировки 316 мс. Объем базы данных 120 Мб.

20150502 04:33
Сегодня нас разбудил звонок от Коли. Ни мне, ни Лене пока не удалось заснуть. Было это в 2 часа ночи...

Зато пришла идея. У меня все никак не получалось быстрое построение индекса в случае po. Причина - в
том, что хеш-функция po дает только 20% различных значений. Вообще-то это логично и странно, что для
s и sp как-то по-другому. 
При этом, построение "классического" индекса не вызвало проблем. Проанализировав, я заключил, что 
при сортировке "классического" индекса сразу вычисляется ключ для всех значений, попадающих в пул
сортировки, а в новом подходе ключи вычисляются по необходимости сравнений. Необходимость сравнений
высокая, так что программа все время "лезет" в разные места диска для вычисления ключа. Похоже, это
можно исправить тем, что если покрытие полуключами не досигает некотрого порога, для сортировки сразу 
привлекается и значение ключа. Посмотрю код.

Воспроизвел построения вчерашнего дня. И с классическим индексом и с полуключем. Второе сработало как-то
не так. Время построения, как всегда большое - 152 сек., а трассировка получилась 221 мс. Теперь
попробую применить оптимизацию.

Похоже на небольшой успех. Теперь время построение базы данных было 54 сек. Но время трассировки - 327 мс.
Система ведет себя нестабильно. Еще один просчет дал 50 сек. на создание БД и 683 мс. на трассировку.
Без загрузки получилось 323 мс.

57
190
339-370

Собственно время вычислений 250 поисков 190-57=133 мс. 
Не такой плохой результат, но TrueRdfViewer давал 34 мс., получается раза в  лучше. Правда компьютеры
весьма разные.

Сейчас запустил проект TrueRdfViewer. Загрузка прошла великолепно. 11.3 сек. на все дела. Файлы: 80.3 Мб
Трассировка делается за 40-44 мс. Да...

Всего 230
41 - кодирование
128 - кодирование + поиск
получается 87 мс. на поиск. Уже не такое сильное различие. А если поменять на классику?

Построение 45 сек., кодирование + поиск = 170 мс. Без загрузки 240-250.
Странный результат, надо проанализировать код.
240 
Кодирование 50-60
Самая маленькая кодирование + поиск = 230 мс., но обычно 240+
Время на загрузку и создание базы данных снижалось до 42 сек.

Полное время на трассировку 386, 390+

Сделал возможно последний вариант в трассировке spo.
979 операций выполнялось 336 мс. Подозреваю, что большая часть времени была потрачена на 
пролог и эпилог.
267 - кодирование
340 - кодирование и поиск
Поэтому поиск оценивается в 70 мс.

После реконструкции продолжительность всех поисков серии 1145 мс. Это несколько дольше, чем 354
Правда на домашнем компьютере было 730-750


20150503 10:21
Ночью сделал ревизию класса GoGraphStringBased, а еще написал идею для интерфеса IGraph - IGra

Загрузка данных прошла за 28.5 сек. Объем данных 242 Мб.
Попробую сделать решение.

Кстати, пришло в голову следующее рассуждение:
Часть базы данных, напр. большой файл 235 Мб в сделанном решении, можно даже не кешировать, особенно
если файлы превышают размер оперативной памяти. А файлы, к которым выполняется множественный доступ,
можно "сильно" откешировать, даже загнать их в оперативную память. Если к большому файлу в результате
запроса производится единичный доступ, то грубо говоря, у нас всегда будет 100 запросов в секунду. 
Это скорость диска. Вроде твердотельный диск работает в 10 раз быстрее. Хорошо было когда я объединял 
триплеты в записи. Выборка одной записи, часто это то, что нужно. В предыдущем построении GoGraphIntBased
кажется было 75 мб. таблица имен и 50 мб. опорная таблица и индексы. Можно предположить, что для
хранения оперативной информации потребуется 50 Гб. на миллиард триплетов. Хорошо это? Надо бы подумать как
обойтись меньшими размерами. А если двумя индексами воспользоваться, построенными на полуключах, может будет
20-25 Гб на миллиард? Все равно много. Надо искать новые решения.

А пока доделаю GoGraphStringBased. Нужно написать методы и потом добавить еще один индекс.

Умозрительно, похоже выявил проблему, могущую возинкнуть в условиях примнения разных ключей к одному 
индексу. Действительно, путь есть индекс sp, сделанный по условиям полной сортировки сначала по s потом по p.
Я могу также изобразить ключ в виде класса, в котором есть два поля и метод сравнения ключей. После этого
я индексный массив могу отсортировать по ключу и его функции сравнения. В функицию сравнения закладывается 
вариант, когда p == null. Получается, что образец может быть частичным и вроде выбор всех по ключу 
даст правильный набор. Однако в динамической части, тако согласованности может и не быть. Боюсь там надо 
сканированием выявлять пары (базовый)ключ-значение и делать сравнение по ключу. Об этом надо будет подумать 
позже. Другой вариант обращаться к поисковой функции с другим ключем, упорядоченность по которому гарантирована
построением по опорному ключу. Напр. в рассмотренном случае индекса sp, можно к нему обращаться с индексом s. 
Ситуация с динамической частью здесь еще хуже - ключ в словаре полный и на этом уровне нет информации о том,
как их совмещать. Однако, у варианта использования базового ключа с обнуленными полями, есть недостаток тот, 
что возможно будут потери на вычисление (сложных) полей, которые не используются. Кажется, что ObjectVariants
вычисляется "с напрягом", хотя это странно...

Трассировочный тест прошел на модели за 5846 мс. Загрузка данных была секунд 40.

Этот ОЧЕНЬ длинны день хочу закончить экспериментами по улучшению решения GoGraphStringBased, назову его 
GaGraphStringBased

Для начала все скопировал и запустил с самого начала.
В режиме загрузки, получилось 
Время загрузки 38 сек.
Время трассировочного теста 3.8 сек. - вот так сюрприз!
Объем получившихся файлов 250 Мб.
Без загрузки ВТТ 5.9 сек. ???

Попытаюсь сделать разогрев.
После разогрева получилось 5.8 сек.
После новой загрузки 6.0 сек.
После очистки файлов и загрузки 3.7 сек ?????????
После новой загрузки 6.0 сек.
После очистки файлов и загрузки 3.8 сек ...

Не понимаю... Предположение: По неизвестным, но регулярным причинам, связанным с только что 
созданным файлам ИЛИ процент использования проессорного времени резко возростает ИЛИ кеши
какое-то время работают лучше. Второе считаю реальнее.  

Теперь попробую поднять уровень абсракции собственно трассировочного теста.
Без проблем, заменив только тип в проедуре на IGra<PaEntry>

Следующий шаг - постепенное создание нужных индексов и встраивание их в отработку запросов.

Начну по недостоющему порядку, с sp.

65 сек., 262 Мб. ВТТ 5.9 сек.
После замены в GetTriplesWithSubjectPredicate инекса на новый ВТТ 2892

Продолжу завтра...

20150504 06:05
Плохо спалось, рано проснулся. Пытался подремать, все равно встал.

Продолжаю создавать индексы. Хорошо бы делать это компактнее, но пока выходит громоздко.
Сейчас перезапустил программу без построения БД, получилось (ВТТ) 1905. Чудеса...
1813, 1647, 1775
Попробую отключить чего-нибудь.

Без spo 1319, 1394, 1312
Еще и без Spo 1228, 1238, 1245

Так что вклад spo заментый, буду его реализовывать через полуключ.
Pfuheprf 48 сек. ВТТ 1868 (это я еще не преставил)
2972, 2997, 3085
Подкорректировал
Загрузка 64 сек. ВТТ 3439 объем данных 274 Мб
без загрузки 3034, 2778, 2759, 2998, 2933 -- что-то не улучшилось...

С отключенным spo 2585, 2600, 2560
снова включенный 2770, 2744 

Сделал выдачу статистики произвел загрузку время загрузки 59 сек.
статистика благоприятна и для sp и для spo  
ВТТ 3199
без загрузки ВТТ 2872, 2774, 2788, 2742
без загрузки, старый вариант 3218, 3151, 3107, 3107 - на этих измерения вроде выгода есть...

Теперь делаю po. Это уже на замену
Загрузка индекса po опять существенно утяжелила задачу и вывела на общее время 94 сек.

И к результату похоже это ничего не добавляет ВТТ 3013, 2785, 3095, 2990, 2804
Пожалуй, как и ранее, я оставлю этот вариант в комментариях. Универсальное решение для po
позволит также реализовать поиск по заданному предикату.

Сделал коррекции, выполнил загрузку - 55 сек. объем 274 Мб.
Странности продолжаются. Теперь снова ВТТ 1779

Завершить перевод на полуключи можно на s-индексе. Он может и не будет особо эффективным,
поскольку повторяемость использования идентификаторов в позиции субъекта будет порядка 7-10.
Тем не менее како-то эффект может образоваться. Как минимум, это будет альтернативное
решение

После загрузки 2735, 2973, 2728

Буду добавлять шкалы

Добавлю в наиболее проблемный индекс s
Время загрузки 74 сек.
ВТТ 1990, но это ничего не означает - после загрузки такое бывает.
2932, 2934, 2906, 2733, 2938, 2745. 
А если вернуть
2737, 2770, 2974, 2732, 2757 - выглядит несколько лучше, но существенной разниы не видно.
А если не искать
ха-ха-ха ======= а этот индекс и не работает...

Теперь sp
После включения шкалы и загрузки ВТТ 1495
без загрузки 1327, 1328, 1521, 1309 - неплохо...

Теперь spo
Загрузка длилась 74 сек., объем данных 286 Мб.
ВТТ 823
Не ожидал!!!
без загрузки 1416, 1165, 1353, 1370  
После стояния БЕЗ ЗАГРУЗКИ 818, 756, 751, 765 - Удивительно!

Контрольный просчет
Загрузка 57 сек. База данных 274 Мб. ВТТ 730
без загрузки 1168, 1175,...


  
 





 

        

   
  


 





   

 
 

 







 

20150419 12:22
Начинаю новый проект в среде RDF-Store-Polar-DB-Lab. Несколько длинноватое название, трудно
запомнить. Проект будет заключаться в создании решений для RDF-движка (TripleStore) на основе
уже созданных решений по универсальному индексу и по универсальной таблице имен. 

Сначала надо за что-то зацепиться. Нужна инфраструктура триплетов. В частности, конструкция 
триплетного объекта и генерация потока триплетов. Посмотрю за что мне "цепляться". 

В принципе, проект RDFTripleStore струтктурирован вполне интересно. Попробую организовать
поток триплетов. 

Ура, получилось! И конфигуратор работает. Его только надо как-то прописать в проекте. Но так, чтобы
он не коммитился.

Теперь мне понадобится граф с интерфейсом IGraph. Граф будет содержать опорную таблицу и индексы.
Ну и методы, конечно. Сначала это будет граф, потроенный на строковых представлениях uri (без кодирования).

20150425 05:33
Почти неделю не работал над проектом... Попробую субботу и воскресенье провести, в этом смысле, эффективно.

Предыдущий этап закончился тем, что я смог построить базовую таблицу в строковом варианте (без кодирования)
и смог посроить индекс sp. После этого, индекс был испытан на данных, взятых из tracing1mln.xml, 13-я 
строка. Проблемы есть, но они "не у меня". Во-первых, я пока не нашел процедуру перевода ObjectVariants из 
объектного представления в структурное. Поэтому проверка правильности выполнена с помощью отладчика. 
Во-вторых, литеральное представление строки "пострадало" - строка исходно была в кавычках:
  <spD subj="http://www4.wiwiss.fu-berlin.de/bizer/bsbm/v01/instances/dataFromProducer10/Product468" pred="http://www.w3.org/2000/01/rdf-schema#label" res="&quot;nonstrikers tambour&quot;" />
но кавычки не воспроизвелись. Посмотрю в код класса ObjectVariants.

Нашел преобразователь Writeble2OVariant(), сделанный в виде статического расширения массива объектов. 
Потом наткнулся на недоделку в виде отсутствия переопределения для ToString(). Сделал переопределение,
после этого получил (почти... с точностью до кавычек) требуемый результат. Кстати, переопределение
сделал не правильно. Правильно так, как текстовый синтаксис велит. Но пока пусь будет так. 

Теперь отложу класс GoGraphStringBased и сделаю (попробую сделать) вариант с кодированием. Кажется, 
все уже продумано, попробую воплотить.

Сначала ввод. Надо его переделать под ввод порциями. Где-то я это уже делал. Сейчас посмотрю.
Перенесу код BufferredProcessing (пока он не вошел в Поляровскую сборку).

Есть еще возможно слабое место в разработке: это объектный вариант:
    public class OV_typed : ObjectVariants
    {
        public readonly string value; public readonly string turi;
    }
Дело в том, что в дальнейшем, может захотеться прератить string turi в кодированное значение.
Пока это выглядит экзотикой, так что можно оставить строкой.

В строковом виде опорная таблица (для 1 млн. берлинского теста) занимает 235 Мб.

Похоже, таблица загрузилась. Это выполнялось 19 сек. Порциями по 500 тыс. База данных 76.5 мб. (!)
Забавно, что пропорция количества идентификаторов к триплетам прямо как у freebase - получилось
150 тыс. кодов.

Теперь попробую построить какой-то индекс, хотя бы s, sp.
Индекс по s (вроде построился) время построение базы данных - 22 сек.

В таблице имен на скорую руку сделаны "главные" методы преобразования строк в коды и обратно.

20150426 09:46
Вчера (вроде) построил индекс s. Сегодня хочу построить и некоторые другие. Также надо сформировать
испытательный стенд на основе файлов tracing. В этих файлах есть запуски поисков и есть результаты. 
Нет временных характеристик. Вроде были какие-то интегральные. Возможно они сохранились в PolarDemo.

Нашел. Год назад я отлаживал RdfTrees и проводил сопоставление с TrueRdfViewer. Главное, можно снова
пропускать эти тесты и выявлять особености тех или иных решений на трассировочных данных. Начинаю. 
Делаю стенд и испытание spO, spD. 

Стенд вопроизвел из предыдущего проекта. Пока могу испытать только spO, spD теперь с ним слился. 
Время тратится несуразно много - 14 сек. на 4 тыс запусков. В принципе, это понятно. Дело в том, 
что spO сейчас это сделанное средствами Linq-фильтрации sPO. Для проверки, реанимирую проект TrueRdfViewer.

Реанимировал. 1 млн. берлина загружается 14 сек. (а у нас - уже 22!). База данных имеет объем 80.3 Мб.
База данных GoTripleStore уже 88Мб.

Пока не проверил то, что наработал. По некоторым признакам, по результату должно быть нормально. 
Сделаю индекс sp. Для этого индекса ключ - пара sp, полуключ - хеш этой пары. 

Теперь строю и sp. Время 21 сек. (11 сек. загрузка, остальное - индексы). 4151 поиск по s p ?o.
А вот TrueRdfViewer дал заметно лучшие результаты: 7085 правильных результатов + 391 "неправильных" 
получилось за 612 мс. Правда есть тонкомть: в TrueRdfViewer используются таблицы spo и spd и запросы
также отличаются. В полтора раза... Не так чтобы сильно много, все же заложен динамизм и универсальность. 
Надо довести эксперимент до реализации всех вариантов. Т.е. нужны еще варианты Spo Spd spo. Похоже при
нынешнем подходе, это два варианта. 

Пытаюсь понять 976 мс. на sp это хорошо или плохо. Во первых надо узнать сколько выполнялось базовых операций.
Это можно измерить. 

Сообразил какое измерение произвести для того, чтобы понять время работы. Я остановил поиск на стадии
преобразования строк субъекта и предиката в коды. Это оказалось существенно: 533 мс. т.е. большую 
часть времени было преобразование. Вторую остановку сделал перед преобразованием результата поиска
в поток триплетов. Время практически финальное: 928-980 мс. Финальное время: 962-991 Можно предположить,
что 20-30 мс. (2-3%) можно сэкономить на том, что не формировать триплеты в выходной поток. Теперь по 
поводу кодирования (субъекта и предиката). Посмотрю все ли правильно я делаю. Как-то долго получается.

В принципе, все соответствует имеющимся нормативам. Расчитываю:
4151 поисков * 2 кодирования * 60 мс. = 500 мс. (!)

На рабочем компьютере результаты аналогичны. Время на тест: 480-520 мс.

20150501 09:43
С Праздником вас, дорогие товарищи, с Днем 1-го мая - междунароным днем солидарности трудящихся!!!

219482
91115
88062
IriInt
Str
Date
Int
Other
DateTimeZone
Lang

iri 0
iriint 491779 различных 66 тыс., различных (p, o) 69255
bool 0
str 59216
lang 28480
double 0
decimal 0
float 0
int 148885 po-различных 6709
DateTimeZone 142400
datetime 0
date 94726
time 0
other 56960
0
0

Похоже, различных предикатов 29 (?)
Если я павильно подсчитал, то всего различных пар (po) 221830. Похоже, дело не в плохих функциях GetHashCode()

Немного восстановлю рабочий вариант программы

Восстановил. С настройками Сергея po-хеш обспечивает разными 219482 триплета. Время построения базы данных
192 сек. Объем базы данных 125 Мб.

Последняя трассировка Spo выполнялась 47 мс.

Попробую в позиции po базовый индекс.

Получилось в чем-то неплохо. Время загрузки базы данных 44 сек. но время трассировки стало 353 мс.
При повторном запуске, время трассировки 316 мс. Объем базы данных 120 Мб.

20150502 04:33
Сегодня нас разбудил звонок от Коли. Ни мне, ни Лене пока не удалось заснуть. Было это в 2 часа ночи...

Зато пришла идея. У меня все никак не получалось быстрое построение индекса в случае po. Причина - в
том, что хеш-функция po дает только 20% различных значений. Вообще-то это логично и странно, что для
s и sp как-то по-другому. 
При этом, построение "классического" индекса не вызвало проблем. Проанализировав, я заключил, что 
при сортировке "классического" индекса сразу вычисляется ключ для всех значений, попадающих в пул
сортировки, а в новом подходе ключи вычисляются по необходимости сравнений. Необходимость сравнений
высокая, так что программа все время "лезет" в разные места диска для вычисления ключа. Похоже, это
можно исправить тем, что если покрытие полуключами не досигает некотрого порога, для сортировки сразу 
привлекается и значение ключа. Посмотрю код.

Воспроизвел построения вчерашнего дня. И с классическим индексом и с полуключем. Второе сработало как-то
не так. Время построения, как всегда большое - 152 сек., а трассировка получилась 221 мс. Теперь
попробую применить оптимизацию.

Похоже на небольшой успех. Теперь время построение базы данных было 54 сек. Но время трассировки - 327 мс.
Система ведет себя нестабильно. Еще один просчет дал 50 сек. на создание БД и 683 мс. на трассировку.
Без загрузки получилось 323 мс.

57
190
339-370

Собственно время вычислений 250 поисков 190-57=133 мс. 
Не такой плохой результат, но TrueRdfViewer давал 34 мс., получается раза в  лучше. Правда компьютеры
весьма разные.

Сейчас запустил проект TrueRdfViewer. Загрузка прошла великолепно. 11.3 сек. на все дела. Файлы: 80.3 Мб
Трассировка делается за 40-44 мс. Да...

Всего 230
41 - кодирование
128 - кодирование + поиск
получается 87 мс. на поиск. Уже не такое сильное различие. А если поменять на классику?

Построение 45 сек., кодирование + поиск = 170 мс. Без загрузки 240-250.
Странный результат, надо проанализировать код.
240 
Кодирование 50-60
Самая маленькая кодирование + поиск = 230 мс., но обычно 240+
Время на загрузку и создание базы данных снижалось до 42 сек.

Полное время на трассировку 386, 390+

Сделал возможно последний вариант в трассировке spo.
979 операций выполнялось 336 мс. Подозреваю, что большая часть времени была потрачена на 
пролог и эпилог.
267 - кодирование
340 - кодирование и поиск
Поэтому поиск оценивается в 70 мс.

После реконструкции продолжительность всех поисков серии 1145 мс. Это несколько дольше, чем 354
Правда на домашнем компьютере было 730-750



28.5 сек. Объем данных 242 Мб.
  


 





   

 
 

 







 
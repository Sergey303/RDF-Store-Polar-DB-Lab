Результаты прогона тестов

Простой индексна статических данных, рабочий компьютер, 1 млн. записей, индекс на строку
Загрузка 389, Построение индекса 2632, 1000GetAllByKey 223

Домашний компьютер, 1 млн. записей, индекс на строку
Загрузка 1291, Построение индекса 5222, 1000GetAllByKey 433 (А обычно, разница бывает в 2.5 раза!)

Рабочий компьютер. 100 тыс. записей. Main2(). Загрузка 50, Построение индекса 229, 1000GetAllByKey 94
Рабочий компьютер. 1 млн. записей. Загрузка 487, Построение индекса 2755, 1000GetAllByKey 138

Домашний компьютер, 1 млн. записей, Main2()
Загрузка 1650, Построение индекса 7089, 1000GetAllByKey 409 (только 2-е измерение в 2.5 раза, другие - больше!)
Загрузка 842, Построение индекса 5438, 1000GetAllByKey 403 (cnt=643, т.е. приблизительно 2/3 поисков успешны)
Загрузка 845, Построение индекса 5526, 1000GetAllByKey 366 (cnt=663, т.е. приблизительно 2/3 поисков успешны)

Получил первый нетривиальный результат в новой системе. Таблица TableView, индекс DynamicIndexUnique, 
индексная таблица IndexViewImmutable:
Домашний компьютер, 100 тыс записей. Загрузка 87, индекс 87, 1000GetAllByKey 269 (cnt=668)
Домашний компьютер, 1 млн записей. Загрузка 818, индекс 5320, 1000GetAllByKey 390 (cnt=661)
Рабочий компьютер, 1 млн записей. Загрузка 462, индекс 2891, 1000GetAllByKey 144 (cnt=670)
Предыдущее, без загрузки, 1000GetAllByKey 190 (cnt=654)
Включение Warmup по индексному массиву, дает 180. Warmup() по опорной таблице почти не дает улучшения: 178
Новая проверка дала 135-138 - вполне неплохо...
Домашний компьютер, 1 млн записей. Загрузка -, индекс -, 1000GetAllByKey 341 (cnt=661)
Домашний компьютер, 1 млн записей. Целый ключ. Загрузка 933, индекс 1984, 1000GetAllByKey 324 (cnt=684), без загрузки 315
Домашний компьютер, 100 тыс записей. IndexKeyImmutable: Загрузка 87, индекс 177, 1000GetAllByKey 108 (cnt=678)
Домашний компьютер, 1 млн записей. IndexKeyImmutable: Загрузка 889, индекс 1973, 1000GetAllByKey 156 (cnt=650)
Домашний компьютер, 100 тыс записей. IndexHalfkeyImmutable, строки: Загрузка 88, индекс 371, 1000GetAllByKey 133 (cnt=672)
Домашний компьютер, 1 млн записей. IndexHalfkeyImmutable: Загрузка 873, индекс 4063, 1000GetAllByKey 182 (cnt=668)
Домашний компьютер, 100 тыс записей. IndexKeyImmutable+Scale(10000): Загрузка 87, индекс 208, 1000GetAllByKey 34 (cnt=652), минимально 15 мс. при 100000 
Домашний компьютер, 1 млн записей. IndexKeyImmutable+Scale(10000): Загрузка 978, индекс 2522, 1000GetAllByKey 58 (cnt=686), минимально 20 мс. при 1000000 
Домашний компьютер, 1 млн записей. IndexKeyImmutable+Scale(auto): Загрузка 866, индекс 2206, 1000GetAllByKey 19 (cnt=630), при auto - длина шкалы совпадает с длиной индексного массива
Ура! Вроде заработало!
Домашний компьютер, 100 тыс записей. IndexHalfkeyImmutable+Scale(10000), строки: Загрузка 94, индекс 396, 1000GetAllByKey 56 (cnt=663)
Домашний компьютер, 100 тыс записей. IndexHalfkeyImmutable+Scale(auto), строки: Загрузка 91, индекс 393, 1000GetAllByKey 50 (cnt=655)
Домашний компьютер, 1 млн записей. IndexHalfkeyImmutable+Scale(auto), строки: Загрузка 847, индекс 4503, 1000GetAllByKey 64 (cnt=690)
А вот для 10 млн. результаты совсе даже не очень: 9120, 149549, 54207 (cnt=664) Еще раз:
21659б 82514, 101101 (676) - как-то плохо... Надо разбираться.
Абсолюно тот же тест дал на рабочем компьютере результаты:
Рабочий компьютер, 10 млн. записей. IndexHalfkeyImmutable+Scale(auto), строки: Загрузка 4851, индекс 33729, 1000GetAllByKey 27 (cnt=670)
Попробую 100 млн., наверное будут проблемы 32-разрядности
Так и есть. Попробую скомпилировать под 64 разряда
Удивительно, но все прошло гладко:
Рабочий компьютер, 100 млн. записей. IndexHalfkeyImmutable+Scale(auto), строки: Загрузка 42015, индекс 397043, 1000GetAllByKey 7668 (cnt=673)
Вопрос: почему "проседает" производительность доступа? Может из-за выхода за пределы кеширования?
======= Домашний
Провожу эксперимент: Работаю с 5 млн. записей, индексирование строки, с получлечем и шкалой. Меняю размер шкалы:
2 млн. 90-100 мс.
3 млн. 75 мс.
4 млн. 74 мс.
5 млн. 72 мс.
2 млн. 74 мс.
1 млн. 73 мс.
500 тыс. 75 мс.
10 тыс. 98 мс.
Без Scale 219 мс.
100 тыс.  77 мс.
1 тыс. 122 мс.
50 тыс. 83 мс.
75 тыс. 78 мс.
Промежуточный вывод: можно ограничиться 50-100 тыс., т.е. фактором 1-2% 
======= Рабочий
Для контроля, повторю эксперимент:
75К - 35
no Scale - 87 
1K - 51
10K - 40
50K - 36
75K - 33
100K - 34
200K - 33
500K - 33
1M - 32
2M - 31
5M - 31
Все подтверждается, поэтому можно установить дефолтный определитель размера шкалы 

Реализовал ячеечный вариант шкалы. ПРовел расчет на таблице из 100 млн. на строковом столбце и полуключем и шкалой.
При созданиии базы данных получилось: 39337, 357681, 79 (667)
При коннекшине: 10 сек. разогрев и 76 мс. Выполнение 1000 запросов 
Разогрев все же дольше, секунд 32. 

============= Тестирование таблицы имен NameTableUniversal =============
Домашний компьютер:
1 млн. неповторяющихся строк. Загрузка 841, построение индексов 4772. поиск 1000строк 175
10 млн. неповторяющихся строк. Загрузка 8604, построение индексов 84121. поиск 1000строк 463 - помнится на этих объемах уже влияла ограниченность памяти
  
Рабочий компьютер:
1 млн. неповторяющихся строк. Загрузка 544, построение индексов 2634. поиск 1000строк 75
10 млн. неповторяющихся строк. Загрузка 4897, построение индексов 34082. поиск 1000строк 87
100 млн. неповторяющихся строк. Загрузка 42752, построение индексов 406085. поиск 1000строк 184

Добавил к строковому индексу шкалу, вроде работает, хотя детально не проверял

Домашний компьютер:
1 млн. неповторяющихся строк. Загрузка 825, построение индексов 5479. поиск 1000строк 77

Рабочий компьютер:
1 млн. неповторяющихся строк. Загрузка 466, построение индексов 2746. поиск 1000строк 33

20150416 Домашний компьютер
В расчете на то, что ввод таблицы идентификаторов порциями работает, провожу расчет.
1 млн. случайных целых в строковом выражении. Загрузка 1-й порцией 6757. (6160 - без построения шкалы)
10 млн. случайных целых в строковом выражении. Загрузка 10-ю порциями 122845. (122322 - без построения шкалы)
Скорость поиска - 63 мс. на 1000. Это при 100 тыс. кодов.
83 мс. на 1 млн.

Рабочий компьютер. 1 млн. 10-ю порциями. Загрузка 6556, поиск 100000 2996 мс. (30 мс. на 1000 тыс.)
Рабочий компьютер. 10 млн. 10-ю порциями. Загрузка 71546, поиск 1000 35 мс.
Рабочий компьютер. 100 млн. 10-ю порциями. Загрузка 530 сек., поиск 1000 45 мс.

 
20150417 Домашний компьютер
Профилирую загрузку базы данных. Меня интересует временная раскладка для InsertPortion()

10 порций по 100 тыс в каждой, широкий 1 млрд. диапазон значений.
Итак: HashSet - 51 47 41 76 40 46 50 50 42 52
ssa - 207 222 200 195 209 195 210 202 219 250
слияние - 218 318 468 510 610 729 785 884 988 999
формирование словаря - 39 35 36 36 46 37 38 44 36 37
total - 551 624 746 818 908 1009 1086 1184 1287 1341
Всего 10 сек. 

10 порций по 1 млн в каждой, широкий 1 млрд. диапазон значений.
Итак: HashSet - 890 832 ... 793 781
ssa - 4597 3801 ... 4028 3931
слияние - 1467 3402 ... 9811 10802
формирование словаря - 701 551 ... 551 546
total - 7656 8588 ... 15187 16063
Всего 122 сек. 

Делаю стенд для тестирования: 2 порции, 5 млн. в одной порции
HashSet  4134  4685
ssa     24854 26163
слияние 44527 58002
словарь  3729  3298
Всего:  77266 92149

Объем получившейся таблицы имен 9948799 (почти 10 млн.). 
Поиск 1000 после коннекта и разогрева 52 мс. Разогрев длится 6.8 сек.
ОБъем файлов в базе данных 360 Мб.

(Ре)построение индексов на указанных данных заняло 313 сек. т.е. почти в 2 раза
дольше, чем первичное построение. В этом надо бы разобраться. Проверю работу.

Разогрев 9 сек., Поиск 1000 - 64

Эксперимент с 1 млн. Время построение 9.6 сек. Объем файлов 36.2
Разогрев 940, время 1000 поисков 61. Повторно 56.
Перепостроение индексов 9 сек. 1000 поисков 72
разогрев 649, 1000 поисков 65 
Еще раз, но уже после уничтоженных индексов. Перепостроение 7.3 сек,
1000 поисков 48

====== Рабочий компьютер
Наконец, 1 млрд. имен загрузился. Загрузка продолжалась 54 тыс. сек.
Файлы базы данных заняли 22.2 Гб. Интересно, какие будут характеристики
по разогреву и по поиску. Мой компьютер имеет ОЗУ 16 Гб. А пока не было 
"холодного" запуска, поиск 10000 элементов занял 1072 сек (!).

"Разогрев" такого количества данных занял 442 сек. Всего имен в таблице: 628 млн.
1000 поисков выполняется зи 2166 мс. т.е. приблизительно в 100 раз хуже, чем
хотелось бы... Это объяснимо.









 
 
 


 